<!-- markdownlint-disable MD033 -->
<!-- markdownlint-disable MD010 -->
<!-- markdownlint-disable MD037 -->

# SQL 進階處理功能

## <font size = 6>各式各樣的函數</font>

* 視窗函數能達成加上排名順位或流水編號等, 一般彙總函數所做不到的進階操作. 具有 GROUP BY 的分割分群(但是不會彙總, 所以不會減少資料數) 和 ORDER BY 的排序功能.
* 視窗函數(window function)又稱OLAP函數.
* OLAP( OnLine Analytical Processing, 線上分析處理 ) : 在資料庫完成的時候, 即時完成資料分析的處理工作.
* 經過 PARTITION 劃分後的紀錄集合稱為"視窗", 代表範圍的意思.p. 8-7
* <font size = 4 color = orange>視窗函數只能寫在 SELECT, ORDER BY 和 UPDATE 的 SET 中.</font> p. 8-11

視窗函數 :

```SQL
<視窗函數> OVER (PARTITION BY <欄位串列>
                    ORDER BY <排序用欄位串列>)
```

* 當作 "視窗函數"  使用的彙總函數 : SUM, AVG, COUNT, MAX, MIN
  * 此函數的括弧內需放入目標
* 視窗專用函數 : RANK, DENSE_RANK, ROW_NUMBER
  * 此類函數括弧內不須放任何東西.
  * RANK 函數 : 若有相同值, 則名次都相同, 下一個不同值的排名會跳過前面相同的數量, eg.1,2,2,2,5
  * DENSE_RANK 函數 : 若有相同值, 則名次都相同, 下一個不同值的排名會依序下去, eg.1,2,2,2,3
  * ROW_NUMBER 函數 : 加上流水編號, 就算有相同值, 名次也不會相同. eg. 1,2,3,4,5
* PARTITIN BY : 分割的串列
* ORDER BY : 要運算哪個欄位的順序, <font color = orange>此 ORDER BY 並不一定會影響最終結果的排序</font>, 若要其最終結果也能排序, 必須再整個 code 後面再補上 ORDER BY.

例子 : 根據不同商品分類, 對其販賣價格進行排名.

```SQL
-- 注 : 雖然書上寫 MySQL 無法執行, 不過在 MySQL 8.0 版本以後就開始引進了視窗函數.
SELECT
    shohin_name,
    shohin_catalg,
    sell_price,
    RANK() OVER (
        PARTITION BY shohin_catalg
        ORDER BY sell_price
    ) AS ranking
FROM
    Shohin;
```

![結果](https://imgur.com/aNOb9BC.jpg)

* PARTITION BY : 用來指定加上順位的對象範圍.
* ORDER BY : 按照哪個欄位、以甚麼樣的順序加上名次

### <font size = 5>也可以不加上 PARTITION BY</font>

若沒加上 PARTITION BY, 則代表不分割進行視窗函數

例子 : 不加上 partition by, 並且使用三種不同的排序方式

```SQL
SELECT
    shohin_name,
    shohin_catalg,
    sell_price,
    RANK() OVER (
        ORDER BY sell_price
    ) AS RANK_sell,
    DENSE_RANK() OVER(
        ORDER BY sell_price
    ) AS DENSE_RANK_sell,
    ROW_NUMBER() OVER(
        ORDER BY sell_price
    ) AS ROW_NUMBER_sell
FROM
    Shohin;
```

![結果](https://imgur.com/NQ2NzEz.jpg)

---

### <font size = 5> 將彙總函數當作視窗函數使用</font>

例子 : 對賣價使用不同的彙總函數當作視窗函數, 計算方式依照 id 的順序.

```SQL
SELECT
    shohin_id,
    shohin_name,
    shohin_catalg,
    sell_price,
    SUM(sell_price) OVER(
        ORDER BY shohin_id
    ) AS SUM_sell,
    AVG(sell_price) OVER(
        ORDER BY shohin_id
    ) AS AVG_sell
FROM
    shohin;
```

![結果](https://imgur.com/wVAuV2v.jpg)

---

### <font size = 5> 限制計算範圍-計算移動平均 </font>

視窗可以進一步限制要計算的範圍, 而此統計範圍又稱為「窗格(Frame)」

可以以 PRECEDING (之前的) 或 FOLLOWING(之後的) 來限制計算方式. 當然也可兩者都使用.

例子 : 計算商品賣價平均, 計算方式除了當前紀錄外, 最多再往前兩筆紀錄.

```SQL
SELECT
    shohin_id,
    shohin_name,
    shohin_catalg,
    sell_price,
    AVG(sell_price) OVER (
        ORDER BY shohin_id
        ROWS 2 PRECEDING
    ) AS PRECEDING_2_AVG_sell
FROM
    shohin;
```

![結果](https://imgur.com/Gj1O4w1.jpg)

例子 : 計算當前紀錄和前後兩筆資料的賣價平均

```SQL
SELECT
    shohin_id,
    shohin_name,
    shohin_catalg,
    sell_price,
    AVG(sell_price) OVER (
        ORDER BY shohin_id
        ROWS BETWEEN 
        1 PRECEDING AND
        1 FOLLOWING
    ) AS AVG_3_sell
FROM
    shohin;
```

![結果](https://imgur.com/lRcKKN7.jpg)
