<!-- markdownlint-disable MD033 -->
<!-- markdownlint-disable MD010 -->

# 重要指令

* SQL 語法雖然可以換行輸入 (每個子句以;做分隔, 子句太長可以換行), 但是中間不能空行.
* 中文字可用反引號`包覆(鍵盤左上角), 字串需用單引號'包覆
* 彙總函數只能寫在 SELECT, HAVING, ORDER BY

1. DDL(資料定義語言, Data Definition Language)

    <font color = red>DDL(資料定義語言) 能建立或刪除資料庫和資料表等用來儲存資料的物件, 規劃資料儲存方式.</font> 以下為 DDL 的指令(關鍵字).
  
   * CREATE : 建立資料庫或資料表等
   * DROP : 刪除資料庫或資料表等
   * ALTER : 修改資料庫或資料表等物件的架構.

2. DML(資料操作語言, Data Manipulation Language)

    <font color = red>DML(資料操作語言) 能查詢或修改資料表內的記錄(以row為單位的資料).</font> 以下為 DML 的指令(關鍵字).
  
   * SELECT : 從資料表查詢記錄
   * INSERT : 將新紀錄儲存至資料表中
   * UPDATE : 修改資料表的記錄
   * DELETE : 刪除資料表的記錄
  
3. DCL(資料控制語言, Data Control Language)
  
    <font color = red>DCL(資料控制語言) 可以用來認可或取消對資料庫執行的變更動作, 另外也能設另外也能設定 RDBMS 的使用者對於資料表等物件的操作權限.</font> 以下為 DCL 的指令(關鍵字).

   * COMMIT : 認可對資料庫進行的變更動作
   * ROLLBACK : 取消對資料庫執行的變更動作
   * GRANT : 賦予使用者操作的權限
   * REVOKE : 測消使用者操作的權限

## 建立資料庫 (CREATE DATABASE 敘述)

```SQL
CREATE DATABASE <資料庫名稱>; #名稱必須使用半形文字, 資料表和欄位也是
```

例子 :

```SQL
CREATE DATABASE shop; # 建立名為shop的資料庫
```

## 建立資料表 (CREATE TABLE 敘述)

```SQL
CREATE TABLE <資料表名稱>
(<欄位名稱1> <資料型別> <此欄位的條件約束>,
 <欄位名稱2> <資料型別> <此欄位的條件約束>,
 <欄位名稱3> <資料型別> <此欄位的條件約束>,
 ...
 <此資料表的條件約束1>, <此資料表的條件約束2>, ...);
```

例子 :

```SQL
CREATE TABLE shohin #建立名為 shohin 的資料表
(shohin_id			CHAR(4) NOT NULL, #建立colname為shohin_id的col, id為四碼, 並且沒有NULL
 shohin_name		VARCHAR(100) NOT NULL, #長度最多 100 個字元的字串
 shohin_catalg		VARCHAR(32) NOT NULL,
 sell_price		    INTEGER, # 整數
 buying_price		INTEGER, 
 reg_data			DATE, # 日期
 PRIMARY KEY		(shohin_id));
```

<font size = 4>PRIMARY KEY : 用於定義一個資料表中的主鍵（primary key）。主鍵是用於唯一標識資料表中每一行的欄位或欄位組合。</font>

主鍵作用如下

* 唯一識別每一行：主鍵確保資料表中的每一行都具有唯一的識別值。這使得可以使用主鍵來準確地識別和操作資料表中的特定行。

* 避免重複和重複資料：主鍵的唯一性要求確保資料表中的每一行都具有不同的主鍵值。這可以防止插入重複或重複的資料，確保資料表中的資料是唯一的。

* 用於關聯和連接表：主鍵常用於建立表之間的關聯和連接。在關聯式資料庫中，主鍵用於定義表之間的關聯，以便在多個表之間建立關聯和查詢。

---

<font size = 5>資料型別</font> (p.1-25)

所有欄位都必須指定此項目, 基本上分為數值型別、字串名別、日期型別等. 另外 (n) 代表最大長度, 有些 RDBMS 代表最大位元組. 並且資料有區分大小寫, 代表大小寫不同代表不同資料.

常用的資料型別如下 :

* INTEGER（整數, INT）：用於存儲<font color = red>整數數值</font>，例如 1、2、-5 等。
* VARCHAR(n)（變長字串）：用於存儲<font color = red>可變長度的字串</font>，其中 n 表示最大長度限制，例如 VARCHAR(50) 表示最大長度為 50 的字串。
* CHAR(n)（定長字串）：用於存儲<font color = red>固定長度的字串</font>，其中 n 表示固定長度限制，例如 CHAR(10) 表示固定長度為 10 的字串, 如果存入的字元沒有這麼長，會自動補空格。
* FLOAT（浮點數）：用於存儲<font color = red>浮點數值</font>，例如 3.14、-0.5 等。
* DATE（日期）：用於存儲日期，例如 '2023-06-15'。
* TIME（時間）：用於存儲時間，例如 '09:30:00'。
* BOOLEAN（布林值）：用於存儲布林（真或假）值，例如 TRUE 或 FALSE。
* BLOB（二進位大型物件）：用於存儲二進位數據，例如圖像、音頻或視頻檔案。

---

<font size = 5>設定條件約束</font>

條件約束是在資料型別之外, 對存入欄位的資料增加限制或條件的功能.

寫在欄位之後的條件約束例子如下 :

* NOT NULL（非空）：確保欄位的值不能為 NULL。
* UNIQUE（唯一）：確保欄位的值在整個資料表中是唯一的，但可以包含 NULL 值。
* DEFAULT（預設）：為欄位指定一個預設值，在插入新記錄時，如果未提供該欄位的值，則將使用預設值。

```SQL
CREATE TABLE my_table (
  id INT,
  status VARCHAR(50) DEFAULT 'active'
);
```

對整個資料表的條件約束例子如下 :

* PRIMARY KEY（主鍵）：用於定義一個或多個欄位作為資料表的主鍵，確保每個值在主鍵欄位中是唯一的並且不為 NULL。
* FOREIGN KEY（外鍵）：用於建立兩個資料表之間的關聯，確保外鍵欄位的值在另一個關聯資料表的主鍵欄位中存在。
* CHECK（檢查）：用於定義一個條件表達式，該條件表達式必須在插入或更新資料時為真。
  
```sql
# 外鍵
CREATE TABLE orders (
  order_id INT,
  customer_id INT,
  order_date DATE,
  PRIMARY KEY (order_id),
  FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

```sql
# 檢查
CREATE TABLE students (
  student_id INT,
  student_name VARCHAR(50),
  age INT,
  grade CHAR(1),
  CHECK (age >= 18),
  CHECK (grade IN ('A', 'B', 'C'))
);
```

---

<font size = 5>刪除資料表</font>

```SQL
DROP TABLE <資料表名稱>;
```

---

<font size = 5>修改資料表結構</font>

對已建立好的資料表進行修改

<font size = 4>新增欄位</font>

```SQL
ALTER TABLE <資料表名稱> ADD COLUMN <欄位名稱> <欄位設定>;
```

<font size = 4>例子 : 增加欄位名稱shohin_info的欄位</font>

```SQL
ALTER TABLE Shohin ADD COLUMN shohin_info VARCHAR(100);
```

---

<font size = 4>刪除欄位</font>

```SQL
ALTER TABLE <資料表名稱> DROP COLUMN <欄位名稱>;
```

<font size = 4>例子 : 刪除欄位名稱shohin_info的欄位</font>

```SQL
ALTER TABLE Shohin DROP COLUMN shohin_info;
```

---

<font size = 4>修改欄位條件</font>

```SQL
ALTER TABLE <table_name>
MODIFY COLUMN <column_name> <欄位條件>;
```

例子 : 把賣價改為總位數10, 小數位數2.

```SQL
ALTER TABLE Shohin
MODIFY COLUMN sell_price DECIMAL(10,2);
```

---

<font size = 5 > 新增資料至資料表 </font>

```SQL
START TRANSACTION;

INSERT INTO <資料表名稱> VALUE (<欄位1資料>, <欄位2資料>, ...);
INSERT INTO <資料表名稱> VALUE (<欄位1資料>, <欄位2資料>, ...);
...

COMMIT;
```

<font size = 4>例子 : 隨便新增資料</font>

```SQL
START TRANSACTION;

INSERT INTO shohin VALUE ('009', 'test', 'test2', 1000, 200, '2010-01-02');

COMMIT;
```

---

<font size = 5 > 補 : 從資料表刪除資料 </font>

```SQL
DELETE FROM <資料庫名稱>.<資料表名稱> # 如果再資料庫中執行, 直接打<資料表名稱>
WHERE 條件
```

<font size = 4>例子 : 刪除 shohin_id 是009和010的資料</font>

```SQL
# 寫法1
DELETE FROM shop.shohin
WHERE shohin_id = '009' OR shohin_id = '010'
```

```SQL
# 寫法2
DELETE FROM shohin
WHERE shohin_id IN ('009','010')
```

---
<font size = 5 > 修改資料表名稱 </font>

```SQL
RENAME TABLE <修改前資料表名稱> to <修改後資料表名稱>
```

```SQL
RENAME TABLE sohin to shohin
```

---
<font size = 5 > 修改欄位名稱 </font>

```SQL
ALTER TABLE <資料表名稱> CHANGE <原始欄位名稱> <修改後的欄位名稱> <資料型別>;
```

```SQL
ALTER TABLE shohin CHANGE reg_data reg_date DATE;
```

---
<font size = 5> 輸出特定欄位資料 : SELECT</font>

SELECT 可以從資料表的所有資料中, 篩選出想要的資料, 此動作也被稱為查詢.

基本的 SELECT 敘述語法

```SQL
SELECT <欄位名稱>, ....
    FROM <資料表名稱>;
```

此敘述, 可以分為 SELECT 和 FROM 兩段被稱為 <font color = red>子句(Clause)</font> 的部分, 子句式完整 SQL 敘述的構成元素.

```SQL
SELECT shohin_id, shohin_name, buying_price
    FROM Shohin
```

---

<font size = 5> 替欄位取別名 : AS</font>

SQL 可以使用 AS 關鍵字, 替欄位取別名. <font color = red>如使用中文必須使用雙引號包覆</font> (不能用單引號)
語法如下 :

```SQL
SELECT <欄位名稱> AS <別名>
    FROM <資料表名稱>;
```

例子 :

```SQL
SELECT  shohin_id       AS  id,
        shohin_name     AS  "商品名稱",
        buying_price    AS  "單價"
    FROM shohin;
```

---

<font size = 5> 輸出常數(Constant)</font>

SELECT 的 AS 也可以讓他輸出固定的字串或數值

例子

```SQL
SELECT '商品' AS  string, 38 AS number, '2009-02-04' AS s_date,
        shohin_id, shohin_name
    FROM Shohin
```

---

<font size = 5> 省略結果中重複的紀錄 : DISTINCT</font>

若想看商品的分類或是組別量, 可以使用. <font color = red>DISTINCT 必須放在第一個欄位名稱前面.</font> 如果有多個欄位名稱, 則是全部相同才省略, 其中 NULL 也算一類.

```SQL
SELECT DISTINCT <欄位名稱1>, <欄位名稱2>, ...
    FROM <資料表名稱>
```

例子 :

```SQL
# 例子1
SELECT DISTINCT shohin_catalg
    FROM shohin
```

```SQL
# 例子2
SELECT DISTINCT shohin_catalg, reg_date
    FROM shohin
```

---

<font size = 5> 篩選特定資料 : WHRER</font>

SELECT 敘述可以使用 WHERE子句 來指定條件、篩選出想要的資料. WHERE子句 會先篩選出符合條件的資料, 在按照 SELECT子句 所指定的欄位進行輸出.

<font size = 4 color = red> SQL各子句有順序關係, WHERE 必須在 FROM 之後</font>

```SQL
SELECT <欄位名稱>, ...
    FROM <資料表名稱>
    WHERE <條件式>;
```

例子 : 篩選出商品分類為'衣物'的資料

```SQL
SELECT shohin_id AS "商品ID", shohin_name AS "商品名稱", shohin_catalg AS "商品分類"
    FROM shohin
    WHERE shohin_catalg = '衣物';
```

 <font size = 5>註解的寫法</font>

```SQL
-- 單行註解

/* 
多行
註解
*/
```

---

<font size = 5>算術和比較運算子</font>

* 算數運算子 : +, -, *, /
* 比較運算子 : =,<>(不等於),<,>,>=..., 都可用於時間
* <font color = red>如果運算對象是NULL, 則結果必定為NULL</font>
* 若想確認是否為 NULL, 可使用 IS NULL 或 IS NOT NULL .
* 不能對NULL使用比較運算子
* <font color = red>字串('1','10','2'等)也能比較大小, 比較方式是使用字典排序.</font> 所以'2' > '10', 'b' > 'ac' > 'ab'

例子 : 輸出商品價格和商品價格 * 2, 並列出只有商品價格 * 2 > 5000 的資料.

```SQL
SELECT shohin_name, sell_price,
        sell_price * 2 AS "sell_price_x2"
    FROM shohin
    WHERE sell_price * 2 > 5000;
```

例子 : 篩選出登入日期早於2009-09-27, 並且購買價格大於1000的資料, 只印出name, catalg, date.

```SQL
SELECT shohin_name, shohin_catalg, reg_date
    FROM shohin
    WHERE reg_date < '2009-09-27' AND buying_price > 1000;
```

例子 : 篩選出販賣價格比購買價格高500元以上的商品

```SQL
SELECT *
    FROM shohin
    WHERE sell_price - buying_price >= 500;
```

例子 : 如果有NULL, 使用比較運算子, 結果會被無視. 就算使用 = NULL 也會被無視.

```SQL
SELECT *
    FROM shohin
    WHERE buying_price <> 2800 or buying_price = NULL;
```

例子 : 篩選出NULL的結果(IS NULL)

```SQL
SELECT *
    FROM shohin
    WHERE buying_price IS NULL;
```

---

<font size = 6>邏輯運算子</font>

* AND, OR, NOT
* AND 比 OR 優先
* 比較運算子除了回傳 TRUE 和 FALSE 外, SQL 也會回傳 UNKNOW. <font color = red>所以 SQL 是三值邏輯.</font>
* NULL 遇上判斷式會被回傳 UNKNOW
* (TRUE OR UNKNOW) = TRUE, (TRUE AND UNKNOW) = UNKNOW
* 邏輯運算的真偽值其結果表稱為真偽表.

例子 : 使用 NOT, 找賣價小於 1000 的商品

```SQL
SELECT *
    FROM shohin
    WHERE NOT(sell_price >= 1000);
```

例子 : 列出商品分類為辦公用品, 並且購買時間是2009-09-11或2009-09-20的商品資料

```SQL
SELECT *
    FROM shohin
    WHERE shohin_catalg = '辦公用品' 
          AND (reg_date = '2009-09-11' OR reg_date = '2009-09-20');
```

---
<font size = 6>查詢時彙總資料</font>

* 計算資料表欄位的總計值或平均值等統計操作, 需要利用彙總函數(Aggregate Function、Group Function)
* 彙總函數基本上會排除 NULL, 不過 COUNT 如果不特別指定含有NULL的 col 而是使用 COUNT(*) 的話, 就不會排除 NULL, 就算資料只有 NULL 也是. 當然在 WHERE 上的條件會先排除.
* 排除重複值進行統計時, 需使用 DISTINCT

### <font size = 5>常用的彙總函數</font>

* COUNT：計算指定欄位中的記錄數量。
* SUM：計算指定欄位的數值總和。
* AVG：計算指定欄位的數值平均值。
* MAX：找出指定欄位中的最大值。
* MIN：找出指定欄位中的最小值

使用方法

```SQL
SELECT COUNT(column_name)
    FROM shohin
```

例子2 : 列出資料總比數、總賣價、總買價、總利潤、平均利潤、最大價差和最小價差, <font color = red>排除買賣價個含有NULL的資料</font>.

```SQL
SELECT COUNT(*) AS "總比數", 
       SUM(sell_price) AS "總賣價",
       SUM(buying_price) AS "總買價",
       SUM(sell_price - buying_price) AS "總利潤",
       AVG(sell_price - buying_price) AS "平均利潤",
       /*
       如果 AVG 這行寫成 AVG(sell_price) - AVG(buying_price) 結果會一樣, 因為後面 WHERE 把 NULL 無視了
       */
       MAX(sell_price - buying_price) AS "最大價差",
       MIN(sell_price - buying_price) AS "最小價差",
       MAX(reg_date) AS "最後購買日期"
    FROM shohin
    WHERE (sell_price IS NOT NULL) AND (buying_price IS NOT NULL);
```

---

<font size = 5>使用彙總函數時先排除重複值 : 使用 DISTINCT</font>

```SQL
SELECT COUNT(DISTINCT(<欄位名稱>))
    FROM <資料表名稱>
```

例子 : 計算資料量、資料總類數

```SQL
SELECT COUNT(*) AS "資料總數量",
       COUNT(DISTINCT(shohin_catalg)) AS "資料總類數"
    FROM shohin
```

---

<font size = 6>資料分群</font>

* GROUP BY 子去可以將資料分群, 例如將資料按照商品分類或是購買日期分群.
* 分群資料若包含 NULL, 則 NULL 也會是獨立一群
* GROUP BY 所指定的欄位稱為「彙總鍵」或「群組化欄位」
* <font color = orange size = 4>子句撰寫順序 : SELECT -> FROM -> WHERE -> GROUP BY</font>
* GROUP BY 注意事項 :
  * GROUP BY 子句只能指定寫在 SELECT 子句中的元素
  * 無法排序彙總結果
  * WHERE 子句中不能寫入彙總函數. p.3-23
  * <font color = orange>若使用 GROUP BY, 則 SELECT 只能使用 數值、字串、彙總函數和群組化欄位(可多個)</font>. 例子 : 不能以商品類別分類又 SELECT 商品名稱, 因為一個欄位只能輸出一個資料.

<font size = 5> GROUP BY 子句 : 按照~分群</font>

```SQL
SELECT <欄位名稱1>, <欄位名稱2>, ...
    FROM <資料表名稱>
    GROUP BY <群組化欄位1>, <群組化欄位2>, ...;
```

例子 : 列出各個商品分類的購買數量

```SQL
SELECT shohin_catalg AS "商品分類",
       COUNT(shohin_catalg) AS "購買數量"
    FROM shohin
    GROUP BY shohin_catalg;
```

例子 : 購買金額1000以下分一群, 1001至3000分一群, 3001以上一群, NULL 一群.

```SQL
SELECT
    CASE
        WHEN buying_price IS NULL THEN "NULL值"
        WHEN buying_price <= 1000 THEN "1000以下"
        WHEN buying_price BETWEEN 1001 AND 3000 THEN "1001~3000"
        ELSE "3001以上"
    END AS buring_price_range,
    COUNT(*) AS "購買數量"
FROM
    shohin
GROUP BY
    buring_price_range;
```

也可以打成

```SQL
SELECT
    CASE
        WHEN buying_price IS NULL THEN 'NULL值'
        WHEN buying_price <= 1000 THEN '1000以下'
        WHEN buying_price BETWEEN 1001 AND 3000 THEN '1001~3000'
        ELSE '3001以上'
    END AS `金額範圍`,
    COUNT(*) AS `購買數量`
FROM
    shohin
GROUP BY
    `金額範圍`;
```

<font size = 4>搭配使用WHERE</font>

例子 : 查看購買項目中的衣物有幾種金額, 並且顯示該金額購買了多少.

```SQL
SELECT 
    shohin_catalg AS `購買項目`,
    buying_price AS `購買金額`,
    COUNT(*) AS `購買數量`
FROM
    shohin
WHERE
    shohin_catalg = '衣物'
GROUP BY
    buying_price;
```

---

<font szie = 6>對彙總結果指定條件</font>

* 使用 COUNT 等函數彙總資料表的資料時, 若要指定條件, 必須使用 HAVING 子句, 而不是 WHERE 子句.
* 彙總函數可以寫在 SELECT, HAVING, ORDER BY 子句中.
* HAVING 子句應該寫在 GROUP BY 子句後
* <font color = orange>WHERE 子句用來「對記錄指定條件」, 而 HAVING 子句則是「對資料群組指定條件」</font>
* 可寫在 HAVING 子句的元素有 : 數值、字串、彙總函數和 GROUP BY 子句所指定的欄位名稱. p.3-28
* 若 WHERER 和 HAVING 都可以完成的結果, 使用 WHERER 所耗時間較少.

HAVING 子句是針對資料群組設置條件

```SQL
SELECT 
    <欄位名稱>, ...
FROM
    <資料表名稱>
WHERE
    <針對紀錄的指定條件>
GROUP BY
    <群組化欄位>, ...
HAVING
    <針對資料群組的條件>;
```

例子 : 查看非辦公用品, 並且在該分類的購買數量超過3的分類為何.

```SQL
SELECT
    shohin_catalg AS `分類`,
    COUNT(shohin_catalg) AS `購買數量`
FROM
    shohin
WHERE
    NOT(shohin_catalg = '辦公用品')
GROUP BY
    shohin_catalg
HAVING
    COUNT(shohin_catalg) > 3;
```

---

<font size = 6>查詢結果排序</font>

* 想要排列查詢結果需使用 ORDER BY 子句
* 在 ORDER BY 子句的欄位名稱後方, 加上 ASC 關鍵字可以指定升冪順序, 或加上 DESC 關鍵字指定降冪順序.
* ORDER BY 關鍵字可以指定多個排序鍵
* NULL 統一放到最前或最後面
* 可以使用 SELECT 子句所取的欄位別名
* 可以使用 SELECT 子句所沒有的欄位和彙總函數
* 建議不要使用欄位編號

```SQL
SELECT
    <欄位名稱>, ...
FROM
    <資料表名>
WHERE
    <針對紀錄的指定條件>
GROUP BY
    <群組化欄位>, ...
HAVING
    <針對資料群組的條件>
ORDER BY
    <排序基準的欄位名稱1>, ...
```

例子 : 印出購買金額的種類和數量, 並且以購買金額的降冪排序

```SQL
SELECT
    buying_price AS `購買金額`,
    COUNT(*) AS `數量`
FROM
    shohin
GROUP BY
    buying_price
ORDER BY
    buying_price DESC;
```

例子 : 查看每個類別的商品數量, 並且數量已升冪排序

```SQL
SELECT
    shohin_catalg AS `商品分類`,
    COUNT(shohin_catalg) AS `商品數量`
FROM
    shohin
GROUP BY
    shohin_catalg
ORDER BY
    COUNT(shohin_catalg);
```

---

<font size = 6> 新增資料 (INSERT) </font>

* 想在資料表中新增資料(紀錄)需使用 INSERT 敘述, 原則上, 每執行一次 INSERT 敘述可新增 1 筆資料.
* 將多個欄位名稱或內容值以逗號隔開, 並且前後已括弧圍起, 此形式稱為串列(List)
* 對資料表所有欄位執行 INSERT 的時候, 資料表名稱後方的欄位串列可以省略.
* 若想存入 NULL, 可在 VALUES 子句的內容值串列中直接寫入 「NULL」
* 資料表的欄位可以設定預設值(初始值), 設置方法為在CREATE TABLE 敘述中對欄位加上 DEFAULT 條件約束.
* 想存入預設值為內容值時, 可以採用在 INSERT 敘述的 VALUES 子句中寫入 DEFAULT 關鍵字(明示方法)、或省略欄位名稱和內容值串列(默認方法)等兩種方式.
* 從其他資料表複製資料時, 可以使用 INSERT...SELECT 敘述

<font size = 5>INSERT 敘述</font>

```SQL
INSERT INTO <資料表名稱> (欄位名稱1,...) 
VALUES (內容值1,...), (內容值2,...),...
```

---

<font size = 5>從其他資料表篩選、複製資料</font>

```SQL
INSERT INTO <目標資料表名稱> (目標資料表欄位名稱1,...)
SELECT 複製的欄位名稱1,... -- 可放入彙總函數
FROM <複製的資料表名稱>
... --可放入其他限制條件
```

例子 : 製作一個各個商品分類後, 計算的總買賣價格的表

```SQL
--  複製資料至表格
INSERT INTO shohin_catalg_sum
SELECT
    shohin_catalg,
    SUM(sell_price),
    SUM(buying_price)
FROM
    shohin
GROUP BY
    shohin_catalg
```

---

<font size = 6>刪除資料 (DELETE) </font>

* 將資料表完全刪除需要使用 DROP TALBE 敘述. 而想留下資料表, 只刪除資料表本身結構或紀錄時, 使用 DELETE.
* 刪除部分紀錄時, 可以使用 WHERE 子句指定刪除對象的條件. 加上 WHERE 子句限制刪除對象紀錄的 DELETE 敘述稱為 「搜尋式DELETE」.
* 因為 DELETE 是刪除資料表內的資料, 而不是欄位, 所以 DELETE 後面不能加上欄位名稱或是*

<font size = 5>DELETE 敘述的基本語法</font>

```SQL
-- 若直接這樣輸入資料表名稱, 則會清空那個資料表的資料
DELETE FROM <資料表名稱>;
```

若要清空資料表, 建議使用 TRUNCATE, 速度相對快

```SQL
TRUNCATE <資料表名稱>;
```

<font size = 5>搜尋式DELETE</font>

```SQL
DELETE FROM <資料表名稱>
WHERE <條件>;
```

例子 : 刪除資料表 'shohin' 裡面, 賣價 >= 4000 的資料

```SQL
DELETE FROM shohin
WHERE
    sell_price >= 4000;
```

---

<font size = 6>修改資料(UPDATE)</font>

* 修改資料表中的資料時, 需使用 UPDATE 敘述
* 若想修改特定紀錄, 可以使用 WHERE 子句指定修改對象的條件, 而已 WHERE 為條件所進行修改的 UPDATE 敘述稱為「搜尋式 UPDATE」.
* UPDATE 敘述能將欄位的值清空為 NULL
* 同時更新多個欄位的時候, 可在 UPDATE 敘述的 SET 子句中列出多個欄位並以逗號分開

<font size = 5>UPDATE 的基本語法</font>

```SQL
UPDATE <資料表名稱>
    SET <欄位名稱> = <新值或算式>
```

例子 :

1. 將登入日期全部修改為 '2009-10-10'
2. 把商品分類為"廚房用品"的販賣價格(sell_price)提高10倍
3. 把 'shohin_id' 為 '0008' 的資料的登入日期改為 NULL

```SQL
-- 修改日期
UPDATE shohin
SET
    reg_date = '2009-10-10';
-- 修改賣價
UPDATE shohin
SET
    sell_price = sell_price * 10
WHERE
    shohin_catalg = '廚房用品';
-- 修改ID = '0008'的資料
UPDATE shohin
SET
    reg_date = NULL
WHERE
    shohin_id = '0008';
```

---

<font size = 5>修改多個欄位</font>

例子 : 把商品分類為"廚房用品"的販賣價格(sell_price)提高10倍, 並且把買價變成一半

```SQL
UPDATE shohin
SET
    sell_price = sell_price * 10,
    buying_price = buying_price / 2
WHERE
    shohin_catalg = '廚房用品';
```

---

<font size = 6> 交易功能 p. 4-25 </font>

* <font size = 4 color = orange>交易是 : 「對資料庫執行一個以上的更新動作時, 這些更新動作的代稱.」</font>
* 交易功能的更新動作會一併執行完畢, 並且藉由交易功能, 可以確認或取消多個更新動作.
* <font color = orange>交易的所有動作結束時, 需使用 COMMIT (確認處理動作) 或 ROLLBACK (取消處理動作) 等2個指令.</font>
  * <font color = orange>COMMIT : 直接套用交易中所有處理動作產生的資料變動, 相當於電腦的覆蓋儲存.</font>
  * <font color = orange>ROLLBACK : 捨棄交易中所以處理動作產生的資料變動, 相當於電腦的不儲存關閉</font>
* DBMS 的交易必須遵守四項原則, 又稱為 ACID 特性.
  * 不可分割性(Atomicity)
    * 交易若執行完畢, 則只有DML全數成功執行或全部取消執行(rollback)兩種情況.
    * 注意 :CREATE TABLE 陳述式可以獨立於交易的執行。這意味著即使在交易中的其他部分有錯誤，創建表的陳述式仍然會成功執行。
  * 一致性(Consistency)
    * 確保資料庫更新前和更新後是一致的狀態, 也就是 DML 必須滿足資料庫預先設定的條件約束, 若沒滿足則該交易會直接rollback.
    * 和 Atomicity 差別在於, Atomicity 確保交易的完全執行或rollback; Consistency 確保資料庫的一致性和完整性.
  * 隔離性(Isolation)
    * 確保各筆交易間不會相互受到干涉影響的性質, 確保交易間不會相互包容形成巢狀結構. 也就是說, 在交易結束前, 其他交易無法得知此筆交易所造成的變動(用code有順序關係比較好理解).
  * 持續性(Durability)
    * 資料更新後不會無故變回去.

需要一併執行完畢的多個動作, 應當整合成單一的「交易」來運用.

交易的語法

```SQL
<交易起始敘述>;
-- mySQL : START TRANSACTION

    DML 敘述1;
    DML 敘述2;
    ...

<交易結束敘述(COMMIT 或 ROLLBACK)>
```

例子 : 將襯衫售價降低1000, 並將T恤售價上升1000.

```SQL
START TRANSACTION;

    -- 將襯衫售價降低1000
    UPDATE shohin
    SET
        sell_price = sell_price - 1000
    WHERE
        shohin_name = '襯衫';
    
    -- 並將T恤售價上升1000
    UPDATE shohin
    SET
        sell_price = sell_price + 1000
    WHERE
        shohin_name = 'T侐';

COMMIT;
```

---

<font size = 5>隔離性(Isolation)</font>

確保各筆交易間不會相互受到干涉影響的性質, 確保交易間不會相互包容形成巢狀結構. 也就是說, 在交易結束前, 其他交易無法得知此筆交易所造成的變動(用code有順序關係比較好理解).


例子 :

```SQL
START TRANSACTION;
-- 隨便新增一個TALBE, 注意 : CREATE TABLE 陳述式可以獨立於交易的執行。這意味著即使在交易中的其他部分有錯誤，創建表的陳述式仍然會成功執行.
CREATE TABLE Test_Isolation(
    ID          CHAR(1)         NOT NULL,
    COL_A       INTEGER         ,
    COL_B       INTEGER         ,
    COL_C       INTEGER         ,
    PRIMARY KEY(ID)
);
-- 隨便給予資料
INSERT INTO Test_Isolation
VALUES
    ('1',1,0,0),
    ('2',2,0,0),
    ('3',3,0,0),
    ('4',4,0,0);
COMMIT;
```

```SQL
/*
TRANSACTION 1
根據隔離性, TRANSACTION 1 並不會受到2的影響.
*/
START TRANSACTION;

UPDATE Test_Isolation
SET COL_B = COL_A;

COMMIT;


-- TRANSACTION 2

START TRANSACTION;

UPDATE Test_Isolation
SET COL_A = COL_A * 2;

COMMIT;

/*
TRANSACTION 3
因為 TRANSACTION 2 已經執行, 所以C會用到更新後的資料
*/
START TRANSACTION;

UPDATE Test_Isolation
SET COL_C = COL_A;

COMMIT;
```
